# Bruteforcing - 완전탐색

<br>

## 1. 시간복잡도

- 완전탐색의 시간 복잡도는 N 이다.
- 모든 경우의 수를 다 체크해서 정답을 찾는 방법

ex) 4자리의 암호로 구성된 자물쇠를 풀려고 시도한다.
이 경우, 0000 부터 9999까지의 모든 경우를 다 시도해보는 것이다. (최대 10,000번의 시도로 해결 가능)

### 잊지 말아야할 Computer Science 문제 해결 규칙

1. 사용된 알고리즘이 적절한가? (문제를 해결할 수 있는가?)
2. 효율적으로 동작하는가?

<br>

## 2. 완전탐색 기법을 활용하는 방법

1. 해결하고자 하는 문제의 가능한 경우의 수를 대략적으로 계산한다.
2. 가능한 모든 방법을 다 고려한다.
3. 실제 답을 구할 수 있는지 적용한다.

<가능한 모든 방법> 에서도 고려해야할 방법
`① BruteForce 기법 - 반복 / 조건문을 활용해 모두 테스트하는 방법`
`② 순열(Permutation) - n개의 원소 중 r개의 원소를 중복 허용 없이 나열하는 방법`
`③ 재귀 호출`
`④ 비트마스크 - 2진수 표현 기법을 활용하는 방법`
`⑤ BFS, DFS를 활용하는 방법`

<br>

## 3. 각 방법에 대한 설명

### `① BruteForce 기법 - 반복 / 조건문을 활용해 모두 테스트하는 방법`

반복 / 조건문을 통해 가능한 모든 방법을 단순히 찾는 경우
`ex) 자물쇠 암호 찾기`

### `② 순열(Permutation) - n개의 원소 중 r개의 원소를 중복 허용 없이 나열하는 방법` - 시간 복잡도 : O(N!)

순열 : 임의의 수열이 있을때, 그것을 다른 순서로 연산하는 방법

### 순서가 중요함

수열에서 숫자가 [1,2,3]이 있다면, 이것을 [1,2,3]으로 보는 순서와 [3,2,1]로 보는 순서가 차이가 있음이 중요한 경우

같은 데이터가 입력된 수열이지만, 그 순서에 따라 의미가 있고 이 순서를 통해 연결되는 이전 / 다음 수열을 찾아낼 수 있는 경우를 계산할 수 있음.
=> N개의 서로 다른 데이터가 있고, 이를 순열로 나타낸다면 전체 순열의 가지 수는 N!개

`ex) {1 2 3} → 최초 순열 - 오름차순, {1 3 2}, {2 1 3}, {2 3 1}, {3 1 2}, {3 2 1} → 최종 순열 - 내림차순`
최초 / 최종 순열이 오름 / 내림차순 임을 알 수 있음. (중복된 숫자가 있다면 비내림 / 비오름차순이 됨)

    사전 순 순열의 규칙을 알아낼 수 있는데, N개의 데이터가 있고 1~i 번째 데이터를 설정했을 때, i번째 데이터 기준 최종 순열은 i+1부터 N까지가 모두 내림차순 이라는 것
    (반대로, 최초 순열이면 i+1부터 N까지 오름차순이다.)

`ex) 1 3 2 → 0번째 숫자 1일때의 최종 순열. 3 2 가 내림차순임을 볼 수 있다.`
이 다음 순열은?

    → i번째가 고정이었고 i+1부터 내림차순인 경우가 최종 순열이므로 다음은 i번째부터 모두 오름차순이 되는 최초 순열이 된다.
    즉, i-1까지는 변동이 없고 i는 i+1~N까지의 숫자 중 자신보다 크지만 가장 작은 숫자와 교환이 되고 그 i+1~N은 다시 오름차순이 되어야한다.

    ∴ 1 3 2 의 다음 순열은 2 1 3 이다.
    (∵ 1 3 2 에서 1은 2와 교체, 1 3 은 오름차순 정렬)

### ※ 순열을 구하는 방법

배열 A={7, 2, 3, 6, 5, 4, 1}, A의 index값 i, j

1. A[i-1] <= A[i] 를 만족하는 i 중 가장 큰 값을 찾는다.
   (혹은 뒤에서부터 찾는 경우 A[i-1] >= A[i] 중 가장 작은 i를 찾는다.)
   → 현재 i값을 기준으로 이후는 모두 내림차순으로 되는 경우를 찾는다. [현재 기준 최종 순열을 찾음]
   A배열을 보면 A[i-1] < A[i]가 되는 가장 큰 i는 6인 3번째(0부터 시작)이다. 즉, i=3이 된다.

2. j >= i 중, A[j] > A[i-1]을 만족하는 가장 큰 j의 값을 찾는다.
   → 현재가 최종 순열 상태이므로 i-1번째 숫자를 변경하여 최초 순열을 찾아야함.
   A배열을 기준으로 i-1번째 숫자는 3으로 3보다 큰 경우는 6, 5, 4 이나 그 중 j값이 가장 큰 경우는 4이다.

3. A[i-1]과 A[j]를 Swap한다.
   → i-1인 2번째 숫자 3과 j인 5번째 숫자인 4를 변경한다.
   A={7,2,4,6,5,3,1}

4. i이후의 순열을 모두 뒤집는다.
   → 최초 순열 상태로 만들어야 하므로 i번째부터는 오름차순으로 만들어야 한다.
   A={7,2,4,1,3,5,6}

### `③ 재귀 호출(Recursive)`

숫자 N개의 숫자 중 M개를 고르는 경우라고 할 때, N과 M이 매우 큰 숫자라면 어떨까?
반복문 X

1. 재귀를 탈출하기 위한 탈출 조건이 필요함
   → 이것이 없으면 n개를 모두 골랐음에도 더 숫자를 선택하고자 하여 선택된 숫자를 저장하는 배열에 범위초과 오류가 나거나,
   다른 자료구조를 쓴 경우 잘못된 출력이 나올 수 있고, 혹은 무한 루프 발생 가능
2. 현재 함수의 상태를 저장하는 Parameter가 필요함
   → 위에서 우리는 curr, cnt를 통해 어떤 숫자까지 선택했는지, 몇 개를 선택했는지 전달하였다.
   이것이 없다면 현재 함수의 상태를 저장할 수 없어 재귀 탈출 조건을 만들 수 없게 되거나 잘못된 결과를 출력하게 됨
3. Return문을 신경 쓸 것
   → 재귀를 통해 이후의 연산 결과를 반환 후 이전 결과에 추가 연산을 수행하는 경우도 있을 수 있다.
   즉, 문제 해결을 위한 정확한 정의를 수행하여야 이것을 완벽히 풀 수 있다.

완전 탐색의 재귀와 DP의 차이점은, DP는 작은 문제가 큰 문제와 동일한 구조를 가져 큰 문제의 답을 구할 시에 작은 문제의 결과를 기억한 뒤 그대로 사용하여 수행 속도를 빠르게 한다는 것이다.

그에 반해 완전 탐색은 크고 작은 문제의 구조가 다를 수 있고, 이전 결과를 반드시 기억하는 것이 아니라 해결 가능한 방법을 모두 탐색한다는 차이가 있다.
(즉, DP는 일반적인 재귀 중 조건을 만족하는 경우에 적용 가능)

`④ 비트마스크 - 2진수 표현 기법을 활용하는 방법`

`⑤ BFS, DFS를 활용하는 방법`
